#! /usr/bin/env ruby

## Token Class
#
# Represents a terminal in the grammer. We only support two kinds at
# the moment, integers and operators.

class Token

  attr_reader :type, :value

  ## Create a Token from a String

  def initialize(t)
     if t =~ /-?\d+/
       @type = :number
       @value = t.to_i
     else
       @type = :operator
       @value = t.to_sym
     end
  end

  def to_s
    "Token<#{type},#{value}>"
  end
end

## End of File Toke
#
# This token is returned indefinitely when there are no more tokens in
# a TokenStream

class EOFToken < Token
  
  def initialize
    @type = :EOF
    @value = :EOF
  end
end

class ParseError < RuntimeError
  
  def initialize(string)
    super "parse error: #{string}"
  end
end

## Token Stream
#
# A sequence of token objects, with one character look-ahead. A Parser
# obejct consumes one of these when generating a parse tree.

class TokenStream

  def initialize(string)
    @iter = string.split.map { |t| Token.new t }.each
    @current_token = nil
  end

  ## Peek At the Next Token
  #
  # Returns the token at the head of the stream, without removing it

  def peek
    @current_token ||= @iter.next
  rescue IndexError
    @current_token = EOFToken.new
  ensure
    @current_token
  end

  ## Chomp The Next Token
  #
  # Eats up a Token of input, making sure that it is the rquired type

  def chomp(type)
    cur = peek
    raise ParseError.new "expecting token #{type} but found #{cur}" if cur.type != type
    @current_token = nil
    cur
  end
end

class Parser


  ## Parse String
  #
  # Converts a string into a stream of tokens and parses it ito a
  # structured representation

  def self.parse(block)
    ts = TokenStream.new block

    puts parse_stream(ts).to_s
  end

  ## Parse a Token Stream
  #
  # Parses a stream of tokens into a strucutred representation of the expression

  def self.parse_stream(ts)
    return if ts.peek.type == :EOF
    lhs = ts.chomp :number
    rhs = parse_stream ts
    [lhs, rhs]
  end

end

Parser.parse $*.join(" ")
