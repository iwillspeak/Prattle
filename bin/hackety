#! /usr/bin/env ruby

## Token Class
#
# Represents a terminal in the grammer. We only support two kinds at
# the moment, integers and operators.

class Token

  attr_reader :type, :value

  ## Create a Token from a String

  def initialize(t)
    if t =~ /[a-z_]+/
      @type = :identifier
      @value = t
    elsif t =~ /-?\d+/
      @type = :number
      @value = t.to_i
    else
      @type = :operator
      @value = t.to_sym
    end
  end

  def to_s
    "Token<#{type},#{value}>"
  end
end

## End of File Toke
#
# This token is returned indefinitely when there are no more tokens in
# a TokenStream

class EOFToken < Token
  
  def initialize
    @type = :EOF
    @value = :EOF
  end
end

class ParseError < RuntimeError
  
  def initialize(expected, found)
    super "parse error: expected #{expected} but found #{found}"
  end
end

## Token Stream
#
# A sequence of token objects, with one character look-ahead. A Parser
# obejct consumes one of these when generating a parse tree.

class TokenStream

  def initialize(string)
    @iter = string.split.map { |t| Token.new t }.each
    @current_token = nil
  end

  ## Peek At the Next Token
  #
  # Returns the token at the head of the stream, without removing it

  def peek
    @current_token ||= @iter.next
  rescue IndexError
    @current_token = EOFToken.new
  ensure
    @current_token
  end

  ## Chomp The Next Token
  #
  # Eats up a Token of input, making sure that it is the rquired type

  def chomp(type)
    cur = peek
    raise ParseError.new type, cur if cur.type != type
    @current_token = nil
    cur
  end
end

class Parser

  ## Parse String
  #
  # Converts a string into a stream of tokens and parses it ito a
  # structured representation

  def self.parse(block)
    p = Parser.new TokenStream.new block
    puts p.parse_expression.to_s
  end

  ## Create a Parser from a TokenStream
  #

  def initialize(token_stream)
    @ts = token_stream
  end

  ## Parse Expression
  #
  # Parses the current token stream and returns the next Expression in
  # it

  def parse_expression
    return if @ts.peek.type == :EOF
    lhs = parse_value
    rhs = parse_expression
    [lhs, rhs]
  end

  ## Parse Value
  #
  # Parse the representation of a value (number or variable reference)
  
  def parse_value
    return @ts.chomp :number if @ts.peek.type == :number
    return @ts.chomp :identifier if @ts.peek.type == :identifier
    raise ParseError.new [:number, :identifier], @ts.peek
  end
      
end

Parser.parse $*.join(" ")
